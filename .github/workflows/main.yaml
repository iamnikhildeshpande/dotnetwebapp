name: "Aus-E-Mart DevSecOps Pipeline"
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  JF_URL: ${{ secrets.JF_URL }}
  JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
  JF_XRAY_URL: https://trial7144t5.jfrog.io/xray # Ensure this is correct
  
  JF_BUILD_NAME: "ausemart-web-app"
  JF_BUILD_NUMBER: ${{ github.run_id }}
  DOCKER_REPO: "docker-local" 
  IMAGE_NAME: "ausemartweb"
  TARGET_IMAGE: "trial7144t5.jfrog.io/docker-local/ausemartweb:${{ github.run_id }}"

jobs:
  build-and-secure:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ env.JF_URL }}
          JF_ACCESS_TOKEN: ${{ env.JF_ACCESS_TOKEN }}
          # The action might ignore JF_XRAY_URL, so we fix it in the next step

      - name: Fix CLI Configuration (The Magic Step)
        run: |
          # We manually update the configuration to ENSURE Xray is set
          # 'setup-jfrog-cli-server' is the default ID created by the setup action
          jf c add setup-jfrog-cli-server \
            --url=${{ env.JF_URL }} \
            --xray-url=${{ env.JF_XRAY_URL }} \
            --access-token=${{ env.JF_ACCESS_TOKEN }} \
            --interactive=false \
            --overwrite

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x' 

      - name: Restore Dependencies
        run: dotnet restore
        # This creates the 'obj/project.assets.json' file that Xray needs

      - name: Gate 1 (Audit Source Code)
        run: |
          # Now this will find the Xray URL in the config and succeed
          jf audit --fail=true --min-severity=High

      - name: Build & Publish Binaries
        run: |
          dotnet build --configuration Release
          dotnet publish -c Release -o ./publish

      - name: Build Docker Image
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ env.JF_BUILD_NUMBER }} .
          docker tag ${{ env.IMAGE_NAME }}:${{ env.JF_BUILD_NUMBER }} ${{ env.TARGET_IMAGE }}

      - name: Gate 2 (Local Image Scan)
        run: |
          jf docker scan ${{ env.IMAGE_NAME }}:${{ env.JF_BUILD_NUMBER }} --fail=true --min-severity=High

      - name: Push to Artifactory
        run: |
          jf docker push ${{ env.TARGET_IMAGE }} \
            --build-name=${{ env.JF_BUILD_NAME }} \
            --build-number=${{ env.JF_BUILD_NUMBER }}

      - name: Final Gate (Build Scan)
        run: |
          jf rt build-collect-env ${{ env.JF_BUILD_NAME }} ${{ env.JF_BUILD_NUMBER }}
          jf rt build-publish ${{ env.JF_BUILD_NAME }} ${{ env.JF_BUILD_NUMBER }}
          
          # This also relies on Xray, so the fix above ensures this works too
          jf build-scan ${{ env.JF_BUILD_NAME }} ${{ env.JF_BUILD_NUMBER }} --fail=true
